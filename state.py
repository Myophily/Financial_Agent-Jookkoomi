# state.py

import operator
from typing import TypedDict, Annotated, List, Dict

from langchain_core.messages import BaseMessage
# LangGraph reducer function for message list accumulation
from langgraph.graph.message import add_messages

# === Agent State Definition ===

class AgentState(TypedDict):
    """
    Defines the state for the JooKkoomi (Stock Analysis Agent).
    This TypedDict stores and updates data throughout the workflow stages.

    TypedDict is like a regular Python dictionary, but with predefined
    type annotations for each key-value pair to ensure type safety.
    """

    # Input values
    target_stock: str
    recipient_emails: List[str]  # Loaded from RECIPIENT_EMAILS in .env file
    current_date: str  # Analysis start date (format: YYYY-MM-DD)              
    
    # Accumulated values (report sections)
    # Group-specific section accumulation (for parallel processing)
    fundamental_sections: Annotated[List[str], operator.add]  # Part 1-5: Fundamental analysis
    technical_sections: Annotated[List[str], operator.add]    # Part 6-8: Technical analysis
    sentiment_sections: Annotated[List[str], operator.add]    # Part 9-11: Market sentiment
    macro_sections: Annotated[List[str], operator.add]        # Part 12-15: Macroeconomic analysis

    # Final consolidated report (injected in Part 16)
    # Annotated[..., operator.add] indicates accumulation (append) rather than replacement
    report_sections: Annotated[List[str], operator.add]

    # Unified report (generated by unify_report node)
    # gemini-2.5-flash standardizes formatting, style, and structure across all sections
    # Falls back to original report_sections if unification fails
    unified_report: List[str]  # No operator.add - replacement operation, not accumulation

    # Korean translation of report (generated by translate_report node)
    # gemini-2.5-flash translates all sections to Korean
    # Falls back to English PDF only if translation fails
    korean_report: List[str]  # No operator.add - replacement operation, not accumulation

    # Failed group tracking (for partial failure handling)
    failed_groups: Annotated[List[str], operator.add]

    # Retry tracking (for failure recovery)
    group_retry_counts: Dict[str, int]  # Track retry count for each group
    permanently_failed_groups: Annotated[List[str], operator.add]  # Groups that failed even after retry

    # Internal management values
    current_part: int  # No Annotated - new values replace old values
    tool_call_count: int  # Track consecutive tool calls in current part (prevents infinite loops)

    # Message history
    # HumanMessage, AIMessage, ToolMessage all inherit from BaseMessage
    # add_messages is a LangGraph-specific reducer optimized for message management
    messages: Annotated[List[BaseMessage], add_messages]


# === Group Worker State (for subgraphs) ===
class GroupWorkerState(TypedDict):
    """
    Defines the state for each analysis group subgraph (Fundamental, Technical, Sentiment, Macro).
    Subgraphs execute independently and return results to the parent state.
    """

    # Inputs (passed from parent state)
    target_stock: str  # Stock ticker to analyze
    current_date: str  # Analysis start date (format: YYYY-MM-DD)
    group_name: str  # Group identifier ("fundamental", "technical", "sentiment", "macro")
    part_range: tuple[int, int]  # Part range (start, end) e.g., (1, 5) = Parts 1-5

    # Outputs (returned to parent state, accumulated via reducers)
    # Each group appends its sections to the corresponding group key
    fundamental_sections: Annotated[List[str], operator.add]  # Fundamental analysis group
    technical_sections: Annotated[List[str], operator.add]    # Technical analysis group
    sentiment_sections: Annotated[List[str], operator.add]    # Sentiment analysis group
    macro_sections: Annotated[List[str], operator.add]        # Macroeconomic analysis group
    failed_groups: Annotated[List[str], operator.add]         # Failed group tracking

    # Internal state (used only within subgraph)
    current_part: int  # Current part number being processed
    tool_call_count: int  # Tool call count for current part (prevents infinite loops)
    messages: Annotated[List[BaseMessage], add_messages]  # Message history within subgraph